/**
 * ═══════════════════════════════════════════════════════════════════════════
 * 50-dictionary.js — Работа со справочником статей доходов/расходов
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * Этот файл управляет справочником статей — списком всех категорий расходов
 * и доходов компании.
 * 
 * Что такое статья?
 * Это категория расхода/дохода, например:
 * - "Зарплата" (расход)
 * - "Выручка по акту" (доход)
 * - "Аренда офиса" (расход)
 * 
 * Что такое расшифровка?
 * Это детализация статьи, например:
 * - Статья "Зарплата" → расшифровка "Сидорову И.И."
 * - Статья "Выручка по акту" → расшифровка "ул.Ленина 15"
 * 
 * Основные задачи:
 * - Быстрый поиск статьи по расшифровке
 * - Автоматическое добавление новых расшифровок
 * - Проверка наличия связки "статья + расшифровка"
 * ═══════════════════════════════════════════════════════════════════════════
 */

/**
 * Загружает справочник и строит индексы для быстрого поиска
 * 
 * Проблема: если в справочнике сотни строк, каждый раз искать перебором — медленно.
 * 
 * Решение: один раз прочитать весь справочник и создать несколько "карт":
 * 1. pairs — Set пар "статья|расшифровка" (для проверки существования)
 * 2. acts — Map статей, для которых нужен акт
 * 3. hashes — Set "хэш-статей" (расшифровка начинается с #, например #Дюбели)
 * 4. meta — Map статей с их типом, категорией и требованием акта
 * 5. byDec — Map расшифровок → множество статей
 * 
 * Теперь все проверки мгновенные!
 * 
 * @param {Sheet} shDict - Лист "Справочник"
 * @returns {Object} - Объект с индексами:
 *   - pairs: Set пар "статья|расшифровка"
 *   - acts: Map статей, требующих акт
 *   - hashes: Set хэш-статей
 *   - meta: Map статья → {t: тип, c: категория, req: требование}
 *   - byDec: Map расшифровка → Set(статей)
 */
function buildDictionaryIndex_(shDict) {
  const pairs  = new Set();   // Пары "статья|расшифровка" для быстрой проверки
  const acts   = new Map();   // Статьи, для которых нужен акт
  const hashes = new Set();   // Хэш-статьи (расшифровка начинается с #)
  const meta   = new Map();   // Метаданные: статья → {тип, категория, требование}
  const byDec  = new Map();   // Обратный индекс: расшифровка → множество статей

  let dict = [];
  if (shDict && shDict.getLastRow() > 1) {
    // Читаем весь справочник одним запросом (колонки A:E)
    dict = shDict.getRange(2, 1, shDict.getLastRow() - 1, 5).getValues();
  }

  // Проходим по каждой строке справочника
  dict.forEach(r => {
    const [t, c, a, d, req] = r; // t=тип, c=категория, a=статья, d=расшифровка, req=требование
    if (!a) return; // Пропускаем пустые строки

    // Запоминаем пару "статья|расшифровка"
    pairs.add(a + '|' + d);

    // Если нужен акт — запоминаем
    if (String(req).toLowerCase() === 'акт') acts.set(a, true);

    // Если расшифровка начинается с # — это хэш-статья
    if (String(d).startsWith('#')) hashes.add(a);

    // Сохраняем метаданные статьи
    if (!meta.has(a)) meta.set(a, { t, c, req });

    // Строим обратный индекс: расшифровка → множество статей
    if (d != null && d !== '') {
      const keyDec = String(d).trim();
      if (!byDec.has(keyDec)) byDec.set(keyDec, new Set());
      byDec.get(keyDec).add(a);
    }
  });

  return { pairs, acts, hashes, meta, byDec };
}

/**
 * Добавляет новые расшифровки в справочник
 * 
 * Когда пользователь вводит расшифровку, которой нет в справочнике,
 * система предлагает добавить её.
 * 
 * Два режима:
 * 1. Батчевый — добавить все сразу без подтверждения каждой
 * 2. Интерактивный — спросить про каждую расшифровку отдельно
 * 
 * @param {Sheet} shDict - Лист "Справочник"
 * @param {Map} toSuggest - Карта: статья → Set(новых расшифровок)
 * @param {Map} meta - Карта метаданных статей (откуда берём тип и категорию)
 * @param {boolean} auto - Авто-режим (если true — не добавляем, работаем без диалогов)
 * @returns {Array} - Массив добавленных расшифровок вида ["Зарплата — Иванову", ...]
 */
function addNewDecodings_(shDict, toSuggest, meta, auto) {
  const newDecs = [];
  if (!toSuggest || toSuggest.size === 0) return newDecs; // Нечего добавлять
  if (auto) return newDecs; // В авто-режиме не добавляем (не показываем диалоги)

  // Спрашиваем: хочет ли пользователь добавить новые расшифровки?
  const wantAdd = confirmDialog_(
    'Новые расшифровки', 
    'Камрад, я вижу новые расшифровки. Хочешь добавить их в справочник?'
  );
  if (!wantAdd) return newDecs;

  // Спрашиваем: добавить все сразу или по одной?
  const addAllAtOnce = confirmDialog_(
    'Режим добавления', 
    'Добавить все сразу (Да) или по одной с подтверждением (Нет)?'
  );

  const rowsToAppend = []; // Накопитель для батчевой записи

  // Обрабатываем каждую статью с новыми расшифровками
  toSuggest.forEach((set, art) => {
    if (!meta.has(art)) return; // Нет метаданных — пропускаем
    const m = meta.get(art); // Берём тип, категорию, требование акта

    // Очищаем и сортируем список расшифровок
    const arr = Array.from(set)
      .map(d => (d == null ? '' : String(d).trim()))
      .filter(d => d !== '')
      .filter((d, i, a) => a.indexOf(d) === i) // Убираем дубликаты
      .sort((a, b) => a.localeCompare(b, 'ru'));

    if (!arr.length) return;

    if (addAllAtOnce) {
      // Режим "все сразу" — просто добавляем в список для записи
      arr.forEach(d => {
        rowsToAppend.push([m.t, m.c, art, d, m.req]);
        newDecs.push(`${art} — ${d}`);
      });
    } else {
      // Режим "по одной" — спрашиваем про каждую
      arr.forEach(d => {
        const resp = confirmDialog_(
          'Добавить в "Справочник"?', 
          `Тип: ${m.t}\nКатегория: ${m.c}\nСтатья: ${art}\nРасшифровка: ${d}\n\nДобавить эту строку?`
        );
        if (resp) {
          shDict.appendRow([m.t, m.c, art, d, m.req]);
          newDecs.push(`${art} — ${d}`);
        }
      });
    }
  });

  // Если есть что записывать батчем — записываем одним запросом (быстро!)
  if (rowsToAppend.length) {
    const last = shDict.getLastRow();
    const startRow = Math.max(2, last + 1);
    try {
      if (!shDict) throw new Error('Лист Справочник не найден');
      shDict.getRange(startRow, 1, rowsToAppend.length, 5).setValues(rowsToAppend);
    } catch (e) {
      console.error('Ошибка записи в Справочник:', e);
      okDialog_('Ошибка', `Не удалось записать расшифровки: ${e.message}`);
      return [];
    }
  }

  return newDecs;
}

/**
 * Добавляет новую статью в справочник
 * 
 * Вызывается когда пользователь создаёт совершенно новую статью
 * (не просто расшифровку к существующей).
 * 
 * Одновременно обновляет индексы meta и byDec, чтобы не пересчитывать их заново.
 * 
 * @param {Sheet} shDict - Лист "Справочник"
 * @param {string} article - Название статьи (например, "Новая категория расходов")
 * @param {string} decoding - Расшифровка (например, "Первая запись")
 * @param {string} type - Тип: "Доход" или "Расход"
 * @param {string} category - Категория (например, "Операционные расходы")
 * @param {boolean} needAct - Требуется ли акт для этой статьи
 * @param {Map} meta - Карта метаданных (обновляется)
 * @param {Map} byDec - Карта расшифровок (обновляется)
 * @returns {boolean} - true если успешно, false при ошибке
 */
function addArticleToDictionary_(shDict, article, decoding, type, category, needAct, meta, byDec) {
  const req = needAct ? 'акт' : ''; // Преобразуем boolean в строку "акт" или ""
  
  try {
    // Добавляем строку в таблицу
    shDict.appendRow([type, category, article, String(decoding).trim(), req]);
    
    // Обновляем индексы в памяти (чтобы новая статья сразу стала доступна)
    meta.set(article, { t: type, c: category, req });
    const kDec = String(decoding).trim();
    if (!byDec.has(kDec)) byDec.set(kDec, new Set());
    byDec.get(kDec).add(article);
    
    return true;
  } catch (e) {
    console.error('Ошибка добавления статьи в справочник:', e);
    return false;
  }
}
